# 카카오 면접 준비

카카오 기술면접에 대비하여 질문과 답 정리



[TOC]



## 1. SSAFY

> 싸피에서 공부한 내용 및 프로젝트 관련 질문



### 1.1. 파이썬

#### 데이터

- 변수: 변수는 박스로, 값을 저장함(할당)
  - 파이썬은 자바나 C와는 달리 튜플을 이용한 동시할당이 가능
  - 식별자로 예약어는 불가(False, None, return 등)
  - **부동소수점이란? **[wiki](https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)
    - 정의: 실수를 근사하여 유효숫자를 나타내는 가수롸 소수점의 위치를 풀이하는 지수로 나누어 표기하는 것
    - 고정 소수점 방식보다 넓은 범위가 표현 가능하나 느림
    - 부동소수점 빼기 연산 시 정확히 0이 안 되는 현상 발생: **왜?**
      - 원래 수를 지수부로 나눈 값이 가수부로 표기되는데 이게 안 나누어 떨어지기 때문[참고](https://www.secmem.org/blog/2020/05/15/float/)
- String
  - Concatenation: 문자열끼리 더하기
  - Interpolation: 중간에 어떤 파트를 다른 데이터로부터 가져오기
    - % operator: `'Hello %s' % 'Bob'`
    - str.format(): `'Hello {}'.format('Bob')`
    - f-strings
- Type Conversion
  - Implicit
    - None은 안 되지만 False는 0으로 변환됨
  - Explicit
    - string -> intger : 형식에 맞는 숫자만 가능
- Short-circuit evaluation
  - `print(5 and 0)` : 5
  - `print(5 or 0)` : 0
- **in 은 느리다. 왜??**
- 표현식과 문장
  - 표현식: 하나의 값으로 환원될 수 있는 문장
  - 문장: 실행 가능한 코드 단위
- 시퀀스형 컨테이너
  - 시퀀스란? 데이터가 순서대로 나열된 것: **반복 가능**
  - immutable: 튜플, 스트링, 레인지
  - mutable: 리스트
  - **수정 가능과 불가능한 이유는?**
    - C에서는 다음과 같이 데이터를 전달함
    - primitive type: call-by-value 변수의 **값을 복사**하여 전달. 함수가 호출될 때 생기는 스택 메모리 안에서 local value로 사용되기 때문에 변경되어도 외부 변수의 값은 그대로
    - reference type: call-by-reference 변수의 **레퍼런스**를 전달
    - 파이썬에서는 call-by-asignment가 사용되는데, 파이썬은 모든 것이 객체이고 immutable의 경우 객체가 arguments로 전달되면 처음에는 call-by-reference로 받으나 값이 바뀌면 call-by-value로 동작
- non-sequence container
  - set, dictionary: **mutable**
  - 딕셔너리의 키는 immutable만 가능

#### 제어문, 반복문

- 삼항 연산자 Ternary Operator:

  - `true_value if <조건식> else false_value`

- `for <임시변수> in <iterable>`

  - enumerate: 인덱스와 값을 함께 활용

  -  ```python
    for id, value in enumerate(1, 2, 3):
        print(id, ":", value)	# 0:1, 1:2, 2:3
    ```

  - for-else: 반복문을 끝까지 시행한 이후에 실행됨

    - 단, break으로 종료되지 않은 경우만

#### 함수

> 특정한 기능을 하는 코드의 묶음: 가독성, 재사용성, 유지보수

- parameter & argument
  - parameter는 **함수를 정의할 때** 매개변수의 역할을 지정함
  - argument는 **함수가 호출될 때** 실제 전달되는 입력값
- Argument
  - 함수는 기본적으로 위치로 인자를 판단: positional arguments
  - Default Argument Value을 가지는 인자 다음에 기본 값이 없는 인자를 사용할 수는 없음
    - 키워드 인자와 가변 인자는 사용 가능
  - `키워드 인자`를 활용한 다음에 `위치 인자`를 활용할 수는 없습니다.
    - 키워드 인자를 쓸거면 뒤에만 쓰거나 다 써야 함!
  - `*args`(가변 인자 리스트)
    - tuple로 처리되며 매개변수에 * 로 표시
    - 매개변수 목록의 마지막에 옴
  - `**kwargs`(가변 키워드 인자): 정해지지 않은 수의 키워드로 이루어짐
    - 딕셔너리로 처리됨
  - ![인자 순서](https://media.vlpt.us/images/ifyouseeksoomi/post/81272e0d-54fc-4101-a76f-23744dca1045/image.png)
- 스코프(유효 범위)
  - **왜 필요한가?** 
    - 긴 코드 내부에서 변수 간 충돌을 방지하기 위해
    -  global은 가능하면 쓰지 말아야 함! `single-responsibility`
  - LEGB rule: Local, Enclosed, Global, Built-in
  - 수명주기
    - 빌트인: 파이썬 실행 이후
    - 전역: 모듈 호출 이후 인터프리터 종료 시까지
    - 지역, 함수: 함수 종료될 때까지. 예외 발생 시 삭제
- 에러
  - 문법 에러
    - EOL: 따옴표 에러
    - EOF: 괄호 닫기 에러
  - 예외: 문법적으로는 옳지만 실행에서 문제가 생긴 경우
    - NameError: 정의되지 않은 변수 호출
    - ZeroDivisionError
    - TypeError
    - ValueError: 타입은 올바르나 값이 적절하지 않은 경우 `int('3.5')`
- try & except
  - 먼저 try를 실행
  - 예외가 발생되지 않으면 종료, 발생되면 except를 실행
    - except 예외클래스 as err
      - 에러 메시지를 표현, err라는 객체를 생성함
    - 튜플을 이용하여 복수의 예외를 지정할 수 있음
    - 예외는 계층화되어 있음: 복수처리할 때는 하위부터
      - 예) KeyError는 LookupError에 포함
  - 에러가 발생하지 않는 경우 실행 시킬 문장은 else를 활용
  - 에러와 관계 없이 실행되야만 하는 코드는 finally 활용
  - **raise와 assert의 차이는?**
    - raise는 항상, assert는 검증식이 거짓일 때 예외가 발생
    - raise는 지정한 예외가, assert는 AssertionError가 발생
    - raise는 오류를 이미 발견한 상황에서 발생시키는 것이고 assert는 간단한 논리 오류를 검사하기 위해서 사용

#### 데이터 구조

- 스트링: 변경 불가, 순서 있음, 순회 가능
  - `.join()`: **느린가??**
    - concatenation은 새로운 문자열을 생성하기 때문에 메모리를 많이 먹고 느림: join이 권장됨
- 리스트: 변경 가능, 순서 있음, 순회 가능
  - `.sort()`: 원본 list를 변형시키고, 리턴값 없음
  - `.reverse()`반대로 뒤집음
  - 리스트의 복사
    - Shallow Copy: 슬라이싱, list()
    - Deep Copy: import copy, copy.deepcopy (오래 걸림)
- 세트: 변경 가능, 순서 없음, 순회 가능, **중복 없음**
  - remove는 에러 뜨는데 discard는 에러 안 뜸
- 딕셔너리: 변경 가능, 순서 없음, 순회 가능
  - `.update()` **이거 필요한 이유?**
  - 딕셔너리 순회하는 방법
    - `for key in dict:`
    - `for key in dict.keys():`
    - `for val in dict.values():`
    - `for key, val in dict.items():`
  - dictionary comprehension
    - `{키:값 for 요소 in iterable if 조건식}`

#### OOP

- 모듈: 특정 기능을 .py 파일 단위로 작성

  - 패키지: 모듈의 집합으로 모듈을 구조화하기 위해 사용 

- 객체: **객체란?**

  - 타입: 공통된 속성과 조작법을 가진 객체들
    - 인스턴스는 특정 타입의 실제 데이터 예시
    - 모든 객체는 특정 타입의 인스턴스이다
    - 클래스는 사용자 정의 데이터형(user-defined data type)
  - 속성: 객체의 상태/데이터
    - 특정 클래스로부터 나온 인스턴스는 모두 해당 속성을 가짐
  - 조작법(method)
    - 특정 개체에 적용 가능한 행위: `객체.메서드()`

- OOP: 프로그램을 객체의 모임으로 파악하는 패러다임

  - 코드의 직관성, 활용의 용이성, 변경의 유연성
  - **절차적 프로그래밍과 비교하면 어떤가?**
    - 명령어의 모음: 입력을 순서대로 처리한 다음 결과를 내는 것
    - 모든 순서를 파악하고 있어야 하기 때문에 유지보수 난해
  - OOP의 특징
    - encapsulation: 변수와 함수를 묶는 것 - 클래스로 구현
    - inheritance:      부모 클래스를 재사용할 수 있음
    - polymorphism

- 메서드

  - 생성자`__init__(self)`: 생성될 때 자동으로 호출 - 인스턴스 속성 정의
  - 소멸자 `__del__(self)`: 소멸될 때 자동으로 호출
    - 인스턴스가 다른걸 참조하면 **Garbage Collector**가 자동으로 kill
    - GC: 메모리 누수를 막기 위해 할당된 메모리 영역 중 쓰이지 않는 영역을 자동으로 해제해주는 것 - 자세한 건 OS로 ㄱ
  - `__str__()`: 특정 객체를 출력할 때 보여줄 메세지
  - 메서드는 호출 시 첫번째 인자로 인스턴스 자신(self)이 전달됨
  - 클래스 메서드
    - @classmethod 데코레이터를 사용해 정의
    - 호출 시 첫 번째 인자로 cls가 전달됨
  - 스태틱 메서드
    - @staticmethod 데코레이터를 사용해 정의
    - 호출 시 인자를 전달하지 않음
  - 인스턴스에서도 클래식, 스태틱 메서드 접근 가능하나 권장하지 않음

- 속성

  - 인스턴스와 클래스 모두에서 같은 속성 이름이 등장하면, **속성 조회는 `인스턴스를 우선`**한다
  - 인스턴스에서 변수 조회가 안되면 클래스, 안되면 상위 클래스 조회 

- 상속

  - class 클래스 이름(상위 클래스 이름) 으로 정의

  - `super()`를 이용해 부모 클래스의 내용 사용

    - ```python
      class Person:
          def __init__(self, name, age, number, email):
              self.name = name
              self.age = age
              self.number = number
              self.email = email 
              
          def greeting(self):
              print(f'안녕, {self.name}')
              
              
      class Student(Person):
          def __init__(self, name, age, number, email, student_id):
              # Person()
              super().__init__(name, age, number, email)
              self.student_id = student_id
      ```

    - 자식 클래스 인자가 부모와 같으면 안 써도 됨

  - 자식 클래스에서 부모 클래스의 메서드 오버라이딩(재정의) 가능

  - **오버로딩** : 같은 이름의 메서드를 여러 개 가지면서 매개변수의 유형과 갯수를 다르게 하는 것. polymorphism을 위한 것이다





### 1.2. HTML/CSS

> HTML과 CSS를 합쳐 퍼블리싱 작업이라고 표현하고 이 작업을 하는 사람을 퍼블리셔라 함

#### HTML

> 웹 컨텐츠의 의미와 구조를 정의
>
> HyperText Markup Language

- 시맨틱 태그
  - 콘텐츠의 의미를 명확히 설명하는 태그
  - 마크업 언어는 텍스트에 역할을 부여하는 것
  - 시맨틱 웹: 웹페이지를 의미와 관련성을 가지는 거대한 DB로 구축하고자 하는 발상
- Document Object Model
  - 웹 페이지에 대한 인터페이스: HTML 요소들의 구조화된 객체 지향 표현
    - 텍스트로 구성된 HTML을 객체 모델로 변환, 브라우저에 내장되어있음
    - 노드 트리로 표현됨: 태그는 줄기, 컨텐츠는 잎
    - JS에 의해 수정될 수 있는 동적 모델
    - **가상 요소**를 포함하지 않음
      - CSS에 사용되는.... 뭐지?
    - **보이지 않는 요소**를 포함
      - `display: none` 스타일 속성을 갖는 요소
  - 브라우저는 문서를 파싱하여 View Port에 뭘 렌더링할지 결정(Render Tree)하고, 해당 렌더링을 수행하는데 렌더 트리를 생성할 때 DOM과 CSSOM이 필요
- 요소
  - 태그 사이의 내용
  - 중첩(nested)될 수 있음
    - 교차해서는 안 됨
    - 인라인 태그(strong, em, i)는 블록 태그를 포함할 수 없음
- 속성
  - 태그의 부가적인 정보: 파일의 경로, 크기 등
  - 요소의 시작 태그에 위치하며 이름과 값의 쌍을 이룸
- DTD(DOCTYPE)
  - 문서타입: HTML5, HTML4, XHTML중 무엇인지 나타내 줌
  - 싸피에서는 html5만 다루었음

#### CSS

> Cascadding Style Sheets
>
> HTML이 사용자에게 어떻게 표시되는지 지정

- 속성과 값
  - 사람이 읽을 수 있는 식별자인 속성(너비, 색 등)에 값을 부여
- CSS 정의 방법
  - 인라인 스타일, 내부 참조, 외부 참조
- CSS Selector
  - 우선순위: `!important`, inline style, id, class, 요소(태그), 순서(cascade)
  - id 선택자
    - `#` 문자로 시작, 아이디는 문서당 하나만 사용 가능
    - 링크 이동이나 for를 사용하는 경우에만 사용
  - class 선택자
    - 마침표 문자로 시작, 해당 클래스가 적용된 문서의 모든 항목 선택
  - 복합 선택자
    - 자손: `selector a selector b`
    - 자식: `selector a > selector b`
- Box Model
  - 컨텐츠를 담을 박스를 지정하고 스타일, 위치, 정렬을 지정함
  - content: 글, 이미지, 비디오 등 요소의 내용
  - padding: 내부 여백, 배경색 및 이미지 지정 가능
  - border
  - margin: 바깥쪽 여백, 배경색 지정 불가. 마진은 큰 쪽으로 결합되어 상쇄될 수 있음
- Display
  - block: 기본 요소
  - inline
    - 줄바꿈이 일어나지 않는 행의 일부요소
    - width, height, mt, mb 지정 불가
    - 상하 여백은 line-height로 지정
  - inline-block: block속성 사용 가능하고 텍스트 흐름대로 나열함
  - none
    - 화면에서 요소가 사라지며 요소가 차지하는 공간도 사라짐
    - `visibility: hidden`은 공간은 사라지지 않음
- Position
  - static: 기본
  - relative: static을 기준으로 위치 이동
  - absolute
    - 부모/조상 기준으로 이동, 부모가 없으면 body에 붙음
    - 과거 위치에 있던 공간은 사라짐: 다른 것에 상관 없이 독자적인 곳에 놓이게 됨
    - 팝업 정보 상자 등 다른 요소와 위치에 간섭하지 않는 UI 기능 만들기
  - fixed: viewport(현재 보이는 영역) 기준으로 이동 - 항상 같은 곳에 위치
- float
  - 옛날에 레이아웃을 만들기 위해 사용되던 기술
- flexbox
  - 아이템 간 공간 배분과 정렬
  - 컨테이너를 선언: `display="flex"`
  - flex-direction, flex-wrap, flex-flow, jistify-content, align-items, align-self, order, flex-grow
- bootstrap

#### 반응형 웹

> 브라우저의 가로 넓이에 **반응**하여 구성 요소가 변하는 기술
>
> 모바일로 웹페이지를 보는 일이 늘어나면서 생김

넓이에 따라 CSS를 추가로 코딩해야 하기 때문에 비용이 증가하는 문제가 있음

.container > .row > col-*



### 1.3. Django

> 장고의 특징: MTV, ORM, admin, URL design, 표현과 로직의 분리(템플릿 상속), 소스 변경사항 자동 반영



#### 프레임워크란?

> 프랜차이즈 같은 것: 앱개발을 지원하기 위한 개발 kit라고 보면 됨
>
> 한 프로젝트에 프레임워크는 하나만 쓸 수 있음

- 애플
  - 코코아: UIKit, AppKit 등
- 구글
  - AndroidFramework
- 웹
  - AngularJS
  - Vue.js
  - React
  - Django



#### MTV



#### CRUD

- csrf token
  - csfr란 이용권한을 도용하여 특정 웹사이트를 공격하는 행위 [참고](https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95)
  - 사용자의 세션에 난수 값을 저장하고 요청을 받을 때마다 세션에 저장된 토큰값과 요청 파라미터에 전달되는 토큰 값이 일치하는지 검증
- 



#### Form/STATIC,Media

##### Form

> Django의 유효성 검사 도구
>
> 입력된 데이터의 유효성을 검증하고, 필요시에 입력된 데이터를 검증 결과와 함께 다시 표시하며, 유효한 데이터에 대해 요구되는 동작을 수행하는 걸 자동으로 해줌

- Form과 ModelForm의 차이
  - Model에서 이미 정의한 필드를 가져와서(상속해서) 만드는 것이 Modelform
    - Model Fields: DB Field 들을 파이썬 클래스화
    - Form Fields: HTML Form Field 들을 클래스화
  - **왜 ModelForm은 requst.POST를 인자로 받는지?**
    - ㅇ

##### Static

> 웹 사이트의 구성 요소 중에서 해당 내용이 고정되어 응답을 할 때 별도의 처리 없이 파일 내용을 그대로 보여주면 되는 파일

- 여기는 읽으면서 한 번 따라해봐야겠는데?

##### Media

> 사용자가 웹에서 올리는 파일 파일 자체는 고정 이지만, 언제/어떤 파일이 정적 파일로 제공 되는지는 예측할 수 없는 파일



#### Authentication

- authentication vs authorization
  - 신원 확인 vs 권한 부여
- 로그인
  - 로그인은 세션을 Create하는 것
  - 신원을 확인(AuthenticationForm)하고 유효성검사를 거친 후 Create(auth_login함수가 수행)



#### REST API





### 1.4. DB

#### ORM

> OOP 프로그래밍 언어를 사용하여 *호환되지 않는 시스템 간에*  데이터를 변환하는 기술
>
> 프로그래밍 언어에서 사용할 수 있는 가상 객체 DB를 만들어 사용

#### 1:N



#### M:N





### 1.5. JavaScript

#### 기본개념

- 역사
  - 처음엔 넷스케이프에서 동적 웹페이지 만들려고 개발
    - Scheme Script를 베이스로 자바 문법과 비슷하게
  - ECMA International에서 문법적 사항을 정리한 문서 ECMA Script 발간(1997)
  - 그러나 MS에서 이를 생까고, 파이어폭스 출시(2004)되면서 크로스 브라우징 이슈 심화
    - JQuery, dojo, mootools 등의 라이브러리를 이용해 다양한 브라우저에서 동작하는 동적 웹사이트를 만들게 됨
  - AJAX 도입
    - 서버와 통신하기 위해 XHR(XMLHttpRequest)객체를 사용하는 것
    - 비동기적으로 수행되며, 페이지의 일부를 업데이트 하고, HTML, JSON, Txt를 교환
  - 크롬 도입(Just In Time compliation): JS 실행 속도가 굉장히 빠름
  - 표준화 논의: ES5출시(2009), ES6출시(2015)
    - 현재는 모든 브라우저가 ES를 잘 따르고 있음
- 구성
  - JS 엔진
    - 메모리 힙: 메모리 할당을 실시
    - 콜 스택: 스택 프레임 코드를 실행, 함수 호출을 일시적으로 저장-관리
  - 이벤트 루프
    - 현재 실행중인 태스크가 없는지(콜스택이 비었는지), 태스크 큐가 비었는지 반복적으로(tick) 확인
    - 콜스택이 비었으면 태스크큐의 첫번째 태스크를 가져옴
  - web api
    - 스택에서 비동기 함수를(ajax, setTimeout) 만나면 여기로 이동
    - 여기서 실행된 함수의 리턴값은 태스크 큐로 이동함
  - task queue(callback queue)
    - FIFO
    - 스택이 비어있을 경우 태스크 큐에서 콜스택으로 전달
    - **마이크로 태스크 큐**
      - Promise의 `then()` 메서드는 여기에 추가됨
      - 이벤트 루프는 태스크 큐보다 여기 있는 함수를 우선적으로 처리
    - Animation Frame이라는 것도 있는데 일단 생략
- 실행 컨텍스트
  - 실행 가능한 코드를 형상화하고 구분
- 특징
  - 비동기성: 싱글 스레드이기 때문
    - 특정 시점에 어떤 일(콜백 함수)을 이어나감
  - Callback 함수: 1급 객체임
    - **1급 객체**: 리턴값으로 사용가능, 함수 인자로 사용가능, 변수 할당가능
    - 연쇄적인 콜백함수의 사용은 콜백 지옥으로 이어짐
  - Promise
    - 콜백 지옥을 해결
    - 성공/실패의 상황을 가정



#### 기본 문법

- `console`
  - 웹 API로, 언어 자체에 포함된 것이 아니라 브라우저가 이해할 수 있는 함수:  브라우저의 Dev Tool에서 직접 사용하기 가능
  - Node.js같은 애들도 포함하고 있음
- `async` vs `defer`
  - 공통점: JS코드를 만나면 parsing과 병렬적으로 JS코드를 다운로드(fetching)
  - async
    - 해당 JS코드 다운로드가 끝나면 실행(executing)
    - 순서에 의존적인 JS코드라면 문제가 생길 수 있음
    - 파싱이 끝나기 전에 실행되기 때문에 필요한 DOM요소가 아직 없다면 문제가 생길 수 있음
    - 파싱을 중단하기 때문에 페이지를 보기까지 시간이 걸림
  - defer
    - 파싱이 완료되면 JS코드를 작성 순서에 따라 실행
- `'use strict'`를 맨 위에 침으로써(ES5에 도입됨) 호이스팅 방지



#### 데이터 타입

- let: 유일한 **변수**(mutable)

  - ES6에 추가됨
  - var는 이제 쓰면 안 됨: 블럭을 무시하기 때문
    - Hoisting: 선언 위치에 상관 없이 제일 위로 선언을 끌어올림
    - 간단한 프로그램에서는 유연하고 좋지만 규모가 커지면 에러의 원인이 됨
  - Increment
    - postIncrement: `value++`
    - preIncrement: `++value`

- **Block Scope**

  - 블럭 {} 밖에서 접근할 수 없게 함
  - 블럭 밖의 변수는 Global Scope
    - 어플이 종료될 때까지 메모리를 차지하므로 사용 최소화 권장
    - 클래스, 함수, 반복문 등 필요한 부분에서만 쓰자

- const(read only)

  - 포인터가 잠겨있기 때문에 값을 재할당할 수 없음(immutable)
  - 보안성
  - thread safety
    - 여러 쓰레드가 동시에 값을 변경하려고 하여 충돌할 일이 없음
  - reduce human mistakes

- **Dynamic typing**

  - 어떤 타입인지 선언하지 않고 런타임 때 타입을 변경할 수 있음

  - 빠르게 프로토타이핑할 때 유용하지만 규모가 커지면 머리 아플 수 있음!

  - ```javascript
    let text = 'hello';
    console.log(`value: ${text}, type: ${typeof text}`)
    text = 1;
    console.log(`value: ${text}, type: ${typeof text}`)
    text = '7' + 5;
    console.log(`value: ${text}, type: ${typeof text}`)
    text = '8' / '2';
    console.log(`value: ${text}, type: ${typeof text}`)
    // value: hello, type: string
    // value: 1, type: number
    // value: 75, type: string
    // value: 4, type: number
    ```

  - 중간에 타입이 바껴서 (스트링 -> 넘버) 인덱싱을 못하는 바람에 런타임 에러가 생기는 등의 문제가 있을 수 있음: TypeScript로 해결

- Operation

  - Short circuit evaluation
    - 파이썬과 마찬가지로 or(||)연산은 true가 나오면 끝
    - 따라서 함수같이 무거운 것은 최대한 뒤로



#### 함수

- Early return, Early exit
  - 조건이 만족될 때 특정 로직이 도는 함수가 있다면
  - 조건이 안 맞는 경우 먼저 리턴, 그 후에 조건이 맞는 경우에 대한 로직을 작성하는 것이 효율적
- function expression: 1급 객체로 기능하게 해 줌
  - function declaration은 호이스팅 가능하나 이것은 불가
    - 변수에 할당된 이후에만 실행
  - anonymous function: 이름 없이 기능만 작성해서 변수에 할당
  - named function: 디버깅하기 편하려고 씀
- Callback
  - 조건에 맞으면 다른 함수(callback func)를 호출
- Arrow function
  - 간단하게 쓰려고 사용
  - `const simplePrint = () => console.log('simplePrint!');`
  - 좀 길어지면 블럭을 써야하지만 블럭 사용시 return 명시해야
- IIFE(Immediately Invoked Function Expression)
  - 함수를 선언하는 즉시 실행하는 것: 함수를 괄호로() 둘러싸면 됨



#### 조건, 반복

- If

  - ```javascript
    const name = 'df';
    if (name === 'ellie') {
        console.log('Welcome, Ellie!')
    } else if (name === 'coder') {
        console.log('You are amazing coder')
    } else {
        cosole.log('unknown')
    }
    ```

  - Ternary operator: 간단할 때만 쓰자

  - ```javascript
    console.log(name === 'ellie' ? 'yes' : 'no')
    ```

- Switch

  - else if를 여러 개 반복하게 되면 스위치 쓰는 것이 좋음

- loop

  - ```javascript
    let i = 3;
    while (i > 0) {
        console.log(`while: ${i}`)
        i--;
    }
    ```

  - do-while: 먼저 do 블럭을 실행해 조건이 맞는지 검사

  - for-loop

  - ```javascript
    for (i = 3; i > 0; i--) {
        console.log(`for: ${i}`);
    }
    ```

  - Nesting(중복 포문) 작성 가능



#### 클래스

> ES6에 도입됨, 이전에는 바로 객체를 만들어서 사용: function을 이용

- 선언

  - `constructor(parameters) {}`: 클래스 필드 정의
    - consructor 없이 publicField, #privateField를 정의할 수 있음
    - 파이썬과 마찬가지로 static, static method 정의 가능
  - 그 밑에 메소드 선언
  - 객체를 만들 때는 `new Class()`

- Getter, Setter

  - 사용자 실수로 class property를 잘못 설정했을 때 수정하게 해줌

  - ```javascript
    class User {
        constructor(name, age) {
            this.name = name;
            this.age = age;
            // getter 정의하는 순간 this.age는 메모리에 올라간 데이터가 아니라 getter를 호출
            // setter를 정의하는 순간 값을 할당할 때 setter를 호출
    
        }
        get age() {
     	   return this._age;
    	}
    	set age(value) {
            if (value < 0) {
                throw Error('age cannot be negative');
            }
        	this._age = value;
            // 할당할 때 setter가 호출되는데 age변수 이름이 같으면 계속 돌기 때문에 '_'를 앞에 붙이는 게 convention
    	}
    }
    ```

- 상속, 다형성

  - extends를 통해 상속함
    -  `class Rectangle extends Shape {}`
    - Overriding 가능: `super.method()`하면 부모 메소드도 사용

- **Object**

  - 클래스를 이용해서 만들거나(new), 중괄호를 이용해서 생성(object literal)
  - object는 key, value의 집합체
    - in operator: 키가 있는지 체크하는 bool 함수
    - for .. in vs for .. of
      - `for (key in ellie) {}`: object 내의 키를 순회
      - `for (value of iterable) {}`: 배열 내의 원소를 순회
  - object의 copy
    - object는 call by reference이기 때문에  
    - for문을 돌면서 일일이 복사를 해주거나(old way)
    - `Object.assign()`을 활용: assign<Target, source1, source2>
      - `const user2 = Object.assign({}, user);`
      - source가 여러 개이고 같은 필드가 있으면 뒤에 있는 것이 덮어씌우게 됨



#### 배열

- 배열 순회
  - `fruits.forEach((fruit, index) => console.log(fruit))`
- 배열 조작
  - 뒤에 추가: `.push()`  뒤에서 빼기: `.pop()`
  - 앞에 추가: `.unshift()`  앞에서 빼기: `.shift()`
  - 앞에서 빼거나 추가하는 것은 굉장히 느리기 때문에 안 쓰는 것이 좋음
- 검색
  - 인덱스 반환: `.indexOf()` 여러개 있으면 제일 먼저 나오는 인덱스 반환, 반대는 `.lastIndexOf()`
  - 존재여부 찾기: `.includes()`  indexOf()도 쓸 수 있는데 포함 안 되어 있으면 -1이 반환됨



#### JSON

- XML

  - HTML과 같은 마크업 언어로, 태그를 이용하여 데이터를 표현함
  - 아웃룩이 XML을 이용하여 데이터를 주고받았기 때문에 AJAX(Asynchronous Javascript And XML), XHR(XML Http Request)에 XML 이름이 들어가 있음

- JSON: JavaScript Object Notation

  - JS의 object가 키-밸류로 이루어져 있듯 JSON도 그러함
  - 프로그래밍 언어나 플랫폼에 상관 없이 사용 가능

- Serialization

  - (언어별로) object를 JSON으로 변환하는 것

  - Object to JSON

    - `JSON.stringify(object)`: object 뒤에 callback함수를 넣어서 변환을 통제할 수 있음
    - 오브젝트 함수는 JSON으로 변환되지 않음: JSON이 될 때 전부 String으로 바꾸기 때문

  - JSON to Object(deserialization)

    - `JSON.parse(json)`

    - json뒤에 reviver이라는 콜백함수를 이용하여 스트링으로 변환된 원본의 객체를 살릴 수 있음

    - ```javascript
      const obj = JSON.parse(json, (key, value) => {
          console.log(`key: ${key}, value: ${value}`);
          return key === 'birthDate' ? new Date(value) : value;
      })
      ```



#### Event

> HTML 문서 내에서 일어나는 일
>
> `click`, `submit`, `keydown`, `mouseover`, `submit`, `change` ...

- addEventListener

  - `EventTarget.addEventListener(type, listener)`

- event.preventDefault()

  - 각 태그의 기본 이벤트가 동작하지 않도록 막음




#### 비동기 처리

> 자바스크립트 자체는 동기적: 호이스팅이 된 이후로는 하나씩 순서대로 실행
>
> 비동기 함수를 만나면 webAPI, 태스크큐 등을 거쳐 비동기적 실행

- **Callback**
  - synchronous callback
  - asynchronous callback
  - callback hell
    - 코드 가독성이 심각함
- **Promise**
  - 비동기를 간편하게 처리할 수 있도록 도와주는 Object
    - 정해진 *장시간의 기능* 을 수행하고 성공한다면 결과를, 실패한다면 에러를 전달
    - 시간이 오래걸리는 코드를 동기적으로 처리하면 다음 라인의 코드가 실행되지 않기 때문에 Promise를 만들어 비동기적으로 처리하는 것이 좋다
      - ex) network, read files
    - Promise 객체를 만들면 executor가 자동적으로 실행됨
    
  - State
    - pending: operation이 실행중일 때(resolve, reject 둘 다 호출하지 않으면 이렇게 됨)
    - fulfilled: operation을 성공적으로 마쳤을 때(resolve)
    - rejected: 파일을 찾을 수 없거나 네트워크에 문제가 생김
    
  - Producer vs Consumer
    - Producer: 원하는 기능을 수행하여 해당 데이터를 만들어 냄
      - 특정 기능이 성공하면 resolve를 통해 데이터를 전달
      - reject는 Error Object를 통해 값을 전달
    - Consumer: 원하는 데이터를 소비함
      - then: promise가 정상적으로 수행되어 resolve를 통해 전달한 값이 value라는 parameter로 들어옴
      - catch: 에러가 발생했을 때 처리하는 방식을 정의하는 callback함수
      - finally: 성공/실패 관계없이 마지막에 호출됨
    - Promise Chaining
      - then을 호출하면 promise가 리턴되고, 여기에 다시 catch를 등록함
      - 이게 콜백지옥을 깔끔하게 만들어주는 핵심
        - 프로미스 객체를 받아오기 때문에 변수명 줄줄이 쓸 필요 없음 [참고](https://youtu.be/JB_yU6Oe2eE?t=1123)
        - 심지어 변수가 1개면 생략도 가능함ㄷㄷㄷ
    
  - **Async**
  
    - promise를 동기적으로 실행하는 것처럼 보이게 해 줌
    - promise위에 API를 제공해줌(`syntatic sugar`)
    - 함수 앞에 async를 써주면 자동으로 (함수 안의 내용물을 실행하는) Promise가 됨
  
  - **Await**
  
    - async가 붙은 함수 안에서만 쓸 수 있음
    - 비동기적인 수행 앞에 붙여주면 해당 수행을 마친 이후에 다음으로 넘어가게 됨
  
  - async & await의 사용
  
    - Promise도 중첩하게되면 결국 콜백지옥과 다를 것이 없음
  
    - ```javascript
      function pickFruits() {
          return getApple().then(apple => {
              return getBanana().then(banana => `${apple} + ${banana}`);
          });
      }
      ```
  
    - ```javascript
      async function pickFruits() {
          const apple = await getApple();
          const banana = await getBanana();
          return `${apple} + ${banana}`;
      }
      ```
  
    - 다만 독립적인 두 과정을 직렬로 수행하면 낭비: 병렬처리 가능
  
    - ```javascript
      async function pickFruits() {
          const applePromise = getApple();
          const bananaPromise = getBanana();
          const apple = await applePromise;
          const banana = await bananaPromise;
          return `${apple} + ${banana}`;
      }
      // 또는 API 사용
      function pickAllFruits() {
          return Promise.all([getApple(), getBanana()]).then(fruits =>
           fruits.join(' + ')                                )
      }
      ```
  
    - 



#### Axios

> Promise 기반의 비동기 요청을 할 수 있는 JavaScript 라이브러리
>
> xhr을 직관적으로 사용할 수 있도록 만들었음

- async, await
  - 비동기로 처리하는 로직을 동기적으로 보이게 만드는 것
  - 함수 앞에 async를 작성, 비동기로 처리되는 로직 앞에 await 작성
  - await는 async function 내부에서만 사용



#### TypeScript

- 사용하는 이유
  - JS의 보완: 컴파일 시 타입을 체크해 에러를 잡아줌
- 장점
  - 안정성 업, IDE 지원, ES6지원
- 단점
  - 하나의 매개변수가 필요할 때도 적용해줘야 함
  - 동적언어로써의 매력 감소: **왜??**
- 동작
  - 브라우저에서 동작하지 않음: 컴파일러를 이용해 js파일로 변환해야 



### 1.6. 자료구조

#### List



#### String



#### Stack



#### Queue



#### Linked List





### 1.7. 관통프로젝트

#### Request



#### JSON



#### CRUD



#### Authentication



#### DB



## 2. CS 기초

> [Tech Interview 블로그](https://gyoogle.dev/blog/) 에 기반하여 CS기초 내용과 정처기 내용을 결합하여 정리



### 2.1. C언어





### 2.2. 자료구조





### 2.3. OS

> 아키텍처가 하드웨어를 배운다면, OS는 하드웨어와 소프트웨어를 **효율적으로** 운영하기 위한 동작원리를 배운다



#### 운영체제의 역할

- 시스템 자원(CPU, 메모리, I/O device, 저장매체) 관리
  - 각 프로그램이 CPU를 얼마나 사용해야 하는가?
  - 각 프로그램이 메모리의 어디에 얼마나 공간을 차지하는가?
  - 입력된 데이터를 어떤 프로그램이 사용하는가? 출력을 어떻게 하는가?
  - 어디에 어떻게 저장하는가?
- 사용자-컴퓨터 간 커뮤니케이션 지원
- 하드웨어와 **응용프로그램** 제어
  - 프로세스 관리, 램 관리, 파일 관리, 디스크 관리, 입출력 관리, 네트워킹/보안
  - 응용프로그램(Application)이란?
    - 소프트웨어에서 OS를 제외한 나머지
  - OS는 응용프로그램을 **실행**하고, **권한**을 관리함
    - 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배



#### OS의 역사

- 60년대 batch processing system(순차 처리) 탄생: 운영체제의 출현
- 60년대 후반 time sharing system, multi tasking 개념 탄생(구현x)
  - 시분할: 다중 사용자 지원 시 **컴퓨터 응답시간** 을 줄일 필요성에 따라 도입
    - 예) 프로그램 실행 중 키보드를 눌렀을 때 화면에 표시되기까지 시간
    - 시분할 시스템에서 시간을 잘게 쪼갤 수록 응답시간이 빨라짐
  - 멀티태스킹: CPU의 활용도 극대화
    - 여러 응용프로그램의 병렬 실행: 이것도 시분할을 이용
    - 멀티프로그래밍: 입출력 등 CPU**안 쓰는 시간에 다른 작업 실행**
- 70년대 UNIX의 탄생: 현대 운영체제 기술 확립(시분할, 멀티 태스킹)
  - C언어가 개발되면서 기존 어셈블리어가 가진 단점(메모리에 직접 할당하기 때문에 하드웨어가 달라지면 재코딩)이 극복되어 범용적 소프트웨어 개발이 가능해짐
- 80년대 PC의 탄생: 터미널 환경 CLI -> GUI(84' Macintosh)
- 90년대 
  - 응용프로그램(엑셀, 워드) 보급과 Windows의 대중화
    - 엑셀을 위해 windows를 사고 위닝을 위해 PS를 삼: killer application
  - 네트워크 기술 발전: www
  - 오픈 소스 운동 활성화: LINUX
- 2000년 이후
  - 오픈 소스 활성화: LINUX, Apache, MySQL, Android, 딥러닝, IoT 관련
  - 가상 머신(한 컴퓨터에 여러 OS 설치), 대용량 병렬 처리 활성화(멀티 코어)



#### 운영체제 구조

> 사용자 - 응용프로그램/쉘 - API - 시스템콜 - OS - hardware

- 사용자 인터페이스
  - 쉘: 사용자가 OS기능과 서비스를 조작할 수 있게 인터페이스 제공
  - 쉘은 터미널 환경과 GUI환경 두 종류로 분류
- 응용프로그램 인터페이스(API)
  - 함수의 집합: 각 "언어 별"로 OS조작하는 함수 존재(`open()` 등)
  - 함수들을 묶어서 라이브러리 형태가 제공됨(C library 등)
    - 리눅스는 어차피 C로 만들었기 때문에 시스템 콜을 직접 사용할 수도 있으나 범용성을 위해 C API가 사용됨
- **시스템 콜** or 시스템 호출 인터페이스
  - OS의 각 기능을 사용할 수 있도록 시스템 콜이라는 함수를 제공
  - API는 내부에서 시스템 콜을 호출
  - 시스템 콜 정의
    - POSIX API, 윈도우 API를 기본으로 각각의 OS에 대한 시스템 콜 개발
- CPU Protection Rings
  - CPU의 권한 모드(사용자 모드: 일반 사용, **커널** 모드: 특권 명령어 실행 및 원하는 작업 수행을 위한 자원 접근 가능 모드)
    - 보통 4개의 링으로 구성되며 핵심인 ring0 커널을 둘러싸고 있음
    - 응용프로그램이 접근하는 것은 ring3
  - **커널**(알맹이, 핵심 이라는 뜻): OS가 CPU를 사용하는 모드
  - 응용프로그램~시스템콜: 사용자 영역, 시스템콜~하드웨어: 커널 영역
    - 커널 영역은 커널 모드에서 실행되는 코드들이 저장된 장소
  - 시스템 콜은 커널 모드로 실행, 커널 모드로 실행하려면 시스템 콜을 거쳐야 함: 응용프로그램이 함부로 전체 컴퓨터를 해치지 못하게 함
  - 프로그램 작동 과정
    - 응용 프로그램이 실행되어 OS 기능이 필요한 API를 호출(사용자 모드)
    - 시스템콜 호출되면서 **커널모드로 변경**
    - OS내부에서 해당 명령이 실행
    - 사용자모드로 변경되고 응용 프로그램으로 돌아가 계속 실행



#### 프로세스, 스케줄링

> 프로세스: 응용 프로그램
>
> 스케줄링: 시분할 시스템 등 여러 응용 프로그램을 CPU에 할당하는 방법

- 배치 처리 시스템: **자동으로** 순차 처리, 선입선출
  - 응답시간 느리고, 동시 실행/다중 사용자 지원이 되지 않음
- 시분할 시스템
  - 멀티태스킹: 단일 CPU에서 여러 응용프로그램이 동시에 **실행되는 것처럼** 보이도록 하는 시스템 -> 응답속도가 극히 빨라서 끊기는 것을 못 느낌
  - 멀티(병렬) 프로세싱: 여러 CPU가 하나의 프로그램을 병렬로 실행해서 속도 극대화
- **멀티 프로그래밍**
  - 프로그램 실행 중 입출력 이벤트 등 시간이 많이 걸리는 **blocking**이 발생하면 CPU가 놀게 되므로 다른 프로그램을 실행
    - 블로킹: [참고](https://sjh836.tistory.com/109)
    - 여기서는 계속 비동기 논블로킹 기준으로 얘기하고 있는듯?
- **프로세스**
  - 메모리에 올려져서 **실행 중인** 프로그램: OS로부터 시스템 자원을 할당받는 작업의 단위
    - 프로그램은 실행되기 전 상태의 명령어의 집합
  - 작업, task, job이라고도 함: 미묘한 차이가 있으나 혼용됨
- 프로세스의 상태(State)
  - new: 생성
  - **ready**: CPU에 넣으면 바로 실행이 가능한 상태
    - ready state queue
  - **running**: 실행 중, ready-running은 스케줄러가 배치(dispatch, interrupt)
    - running state queue
    - PC(Program Counter)가 현재 가리키고 있는 곳이랄까?
  - **blocked(ing)**: 특정 이벤트 발생 대기(입출력 등), **끝나면** ready로 변경
    - block state queue
    - 끝났는지는 누가 알려줌?: **interrupt**
      - interrupt: 프로세스를 중단시키는 기술
      - 선점형 스케줄러에서 필수적인 기술
      - 주요 인터럽트
        - 내부(software interrupt): ZeroDivision, 잘못된 인덱스, Overflow
        - 외부(hardware interrupt): 전원이상, 타이머, I/O
      - IDT(Interrupter Discriptor Table)에서 해당 인터럽트 주소를 찾아서 실행
        - 시스템 콜도 인터럽트: `0x80`
  - exit: 종료되면 프로세스가 가진 시스템 자원을 돌려놓음
- **스케줄링 알고리즘**
  - 어느 순서대로 프로세스를 실행시키는가?
    - 스케줄러: 프로세스 실행을 관리
  - FIFO: CPU를 처음부터 끝까지 사용
    - 배치 처리 시스템
    - First Come First Served Scheduler
  - SJF(Shortest Job First)
    - 가장 실행시간이 짧은 프로세스부터 실행
    - 프로세스의 실행시간을 정확히 예측할 수는 없으므로 이상적임
    - 응답시간이 FIFO보다 짧음
  - 우선순위 기반 스케줄러
    - 정적 우선순위: 프로세스 별로 미리 우선순위를 지정
    - 동적 우선순위: 스케줄러가 상황에 따라 우선순위를 변경
  - Round Robin 스케줄러
    - 기본적으로 FIFO로 동작하나, 특정 시간동안 프로세스가 끝나지 않으면 준비 큐(RoundRobin Ready Queue)로 넣어줌
  - 선점형/비선점형 스케줄러
    - 비선점형은 프로세스가 1. 자발적으로 blocking 상태가 되거나 2. 실행이 끝났을 때만 교체가 일어남: 응답시간이 길어질 수 있음
- **Context Switching**: 프로세스 교환
  - 이를 이해하려면 프로세스의 구조를 이해해야 함
  - 프로세스 구조
    - Stack: 임시 데이터 - 함수를 실행한 후 그 다음에 실행할 주소(RET), 함수 내 지역변수 및 인자
      - 버퍼, 변수, RBP(Base Point), RET(Return Address)로 구성됨
      - main내에서 sum을 불러오면 RET-RBP-변수c-버퍼-변수x-변수y-RET-RBP-버퍼 순으로 쌓이게 됨
        - 함수를 불러올 때는 해당 함수의 파라미터가 RET아래에 들어감
      - **Stack Overflow**: 스택 내에 공간이 모자라 데이터가 덮어씌워지는 경우가 있음. 이걸 악용해 RET 값을 원하는 값으로 변경해 권한을 얻고 공격하는 기법
    - Heap: 코드에서 **동적으로** 만들어지는 변수
      - 동적 할당: 입력되는 데이터에 맞게 기억공간을 확보하는 것
    - Data(BSS, Data): 초기화 안 된 전역변수(BSS), 초기화 된 전역변수(Data)
    - Code: 컴파일된 소스 코드
  - Context: PC(Program Counter), SP(Stack Pointer)
    - PC는 프로세스 내부에서 한줄씩 따라가는 포인터
    - SP는 스택 내부의 포인터
    - 컨텍스트 스위치가 일어날 때, context를(PC, SP) **PCB**라는 저장공간에 저장해두고 다른 프로세스 실행
      - 프로세스는 운영체제에서 **PCB(process control block)**으로 표현됨
      - 프로세스 메타데이터(ID, register값, 스케줄링 정보, 메모리 사이즈) 저장, 프로세스가 생성될 때 PCB가 생성되고 프로세스 완료 시 제거됨
      - PCB는 메모리에 저장됨
    - 다시 실행할 때는 CPU내부 레지스터에 PCB를 불러와 덮어씌움
    - 컨텍스트 스위치는 어셈블리어로 작성됨: 각각의 CPU에 대해 작성
- 프로세스간 커뮤니케이션(InterProcess Communication)
  - 프로세스는 다른 프로세스 공간 접근 불가: 데이터/코드가 바뀌는 것을 막기 위해
  - 통신을 해야 하는가?
    - 여러 프로세스 동시 실행시 프로세스간 상태 확인 및 데이터 송수신 필요
    - fork()를 이용하여 똑같은 프로세스를 만들어 병렬처리하는 방법 등이 있음
  - 어떻게 하는가?
    - file을 이용하여 저장매체 공유하는 방법: 느리고, 실시간으로 업데이트 어려움
    - 커널 공간을 이용: 메세지 큐, 공유 메모리, 파이프, 시그널, 소켓 등
      - 프로세스들이 커널 공간은 공유하기 때문(자세한건 가상메모리 참고)



####  쓰레드

> 





#### 프로세스 vs 스레드

- 프로세스
  - **Multi Process**
    - 한 작업을 여러 프로세스가 처리
    - Context Switching(프로세스의 상태 정보를 저장하고 복원하는 일련의 과정) 비용이 큼
    - **오버헤드(과부하)** : CPU가 프로세스를 계속 수행할 수 있도록 다른 프로세스를 실행시키고 context switching을 시킴
    - 자식 프로세스 중 하나에 문제가 생겨도 다른 것에 문제 없음
    - 예) 크롬
- 스레드
  - 프로세스 **내에서** 실행되는 흐름의 단위, CPU 이용의 기본 단위
  - 각각의 스레드는 별도의 stack 영역을 가짐
  - **Multi Thread**
    - 프로세스 자원(힙, 데이터, 텍스트)을 공유
    - Context Switching 비용이 적지만 하나의 스레드가 망가지면 모든 스레드가 작동 불능
    - 예) 웹 서버: 하나의 페이지를 요청하는 데 여러 스레드가 할당되어 처리됨
- 프로세스 주소 공간
  - 프로그램이 실행되면 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨
  - 코드(텍스트): 프로그램 소스 코드
  - 데이터: 전역변수
  - 힙
  - 스택: 함수, 지역 변수



### 2.4. DB

> 데이터의 무결성을 유지하면서 효율적으로 다룰 수 있도록 탄생한 방법론

#### Key

- 유일성: 하나의 tuple을 유일하게 식별 가능한가
- 최소성: 꼭 필요한 속성으로만 구성되었는가
- 키의 종류
  - 후보키: 기본키로 사용가능(유일성, 최소성 만족)
  - 기본키: null값을 가질 수 없음
  - 대체키: 후보키 중 기본키가 되지 않은 키
  - 슈퍼키: 유일성만 만족하는 키

#### RDBMS

- 특징
  - 정해진 데이터 스키마에 따라 테이블에 저장됨
    - 데이터 무결성의 보장
    - 쿼리가 복잡해지고 유연하지 않음
  - 관계를 통해 여러 테이블에 분산됨
  - **조인**이 가능함
    - 
- NoSQL
  - 비관계형 DB: 스키마도 없고 관계도 없음
    - 유연하고 데이터를 app이 필요한 형식으로 저장하기 때문에  읽기가 빠름
    - 수정 시 모든 컬렉션에 대해 수행하고, 중복을 계속 업데이트에 해야 하기 때문에 관리하기 어려움
  - 다른 구조의 데이터를 같은 컬렉션에 추가 가능
  - 레코드는 문서(documents)라고 하며 JSON과 비슷한 형태
  - 관련 데이터는 동일 컬렉션에 들어가며 여러 테이블에 조인할 필요 없이 이미 필요한 모든 것을 작성
    - 조인하지 않기 때문에 잘 변경되지 않는 데이터에 사용됨
- 확장
  - 수직적 확장: DB성능 향상
    - SQL은 이것만 지원함
  - 수평적 확장: 서버의 추가, DB의 분산



#### 정규화

> anomaly를 방지하기 위해서 수행

- anomaly
  - 삽입 이상: 불필요한 데이터를 추가해야 삽입이 가능한 상황
  - 갱신 이상: 일부만 변경하여 데이터가 불일치 하는 모순의 문제
  - 삭제 이상: 필요한 데이터까지 같이 삭제되는 문제



#### 인덱스

> 검색 속도를 높이기 위한 기술
>
> column을 색인화하여 따로 파일을 만들어 저장

- 사용 과정
  - 테이블 저장 시 FRM(스키마), MYD(데이터), MYI(인덱스) 파일이 생성
  - 인덱싱을 하는 경우 MYI파일이 생성됨
  - select 쿼리로 인덱스를 사용하는 컬럼 탐색 시 MYI파일 내용 검색됨
- 장단점
  - 빠름
    - where에서 자주 사용되는 컬럼
    - 외래키가 사용되는 컬럼
  - 파일 크기 증가
  - 잦은 변경 시 성능저하(DML이 자주 일어나는 경우)
    - 삭제 시 인덱스와 테이블의 데이터 수가 달라질 수 있음
    - 인덱스는 업데이트 불가



#### 트랜잭션

> db의 상태를 변화시키기 위해 수향하는 작업의 단위

- 예시
  - 송금하는 경우 A계좌 차감 + B계좌 추가
  - 2개 쿼리문을 묶어 하나의 트랜잭션
- 특징:  ACID
  - Atomicity 원자성: all or nothing
  - Consistency 일관성: 
  - Isolation 독립성: 다른 트랜잭션에 끼어들 수 없음
  - Durability 지속성: 트랜잭션 결과는 영구적으로 반영
- 커밋과 롤백
  - 커밋: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용
  - 롤백: 트랜잭션의 비정상적 종료로 원자성이 꺼진 경우 시작 상태로 롤백
- Locking
  - 다른 트랜잭션이 관여하지 못하도록 막는 것
  - Read Uncommited (level 0)
    - 아직 커밋되지 않은 데이터를 읽는걸 허용
    - **dirty read** 발생 가능
  - Read Commited (level 1)
    - 커밋된 트랜잭션만 조회 가능
    - SQL의 default
  - Repeatable Read (level 2)
  - Serializable (level 3)



### 2.5. Network

#### 인터넷

> 모든 컴퓨터를 하나의 통신망 안에 연결(International Network)

- 구성
  - 프로토콜: TCP(Transmission Control Protocol), IP(Internet Protocol)
  - 통신망: 근거리(LAN), 원거리
  - 주소 체계: IP주소 방식, DNS주소 방식
  - 종단 시스템: HOST, 서버, 통신 링크, 처리량 등
  - 접속 제공: 웹 브라우저, ISP(Internet Service Provider), URL
- 기본 용어
  - 패킷: 정보를 **일정한 크기**로 분할한 뒤 각각의 데이터에 송수신 주소 및 부가 정보 입력
    - 패킷 교환: 원거리 통신망의 연결 기술로 전체 메시지를 각 노드가 수용 가능한 크기(패킷)으로 잘라서 송수신
  - 프로토콜: 데이터 교환을 원활히 하기 위한 통신 규약
    - 구문: 데이터 형식, 코딩, 신호 레벨
    - 의미: 조정과 에러 처리를 위한 제어 정보
    - 타이밍: 속도 조절과 순서 관리



#### OSI 7계층

> Open Systems Interconnection Reference Model

- 각 계층은 하위 계층의 기능을 이용하여 상위 계층에 기능을 제공, 계층을 지날 때마다 헤더가 붙음
- 물리
  - 단위는 bit, 장치는 허브(리피터)
  - 물리적 연결의 성립 및 종료, 전기 신호 변조/복조
- 데이터 링크
  - 단위는 프레임(데이터+헤더+트레일러), 장치는 스위치/브리지
  - 프레이에 Mac주소를 부여하고 이를 통해 통신함
  - 포인트 투 포인트 간 신뢰성 있는 전송 보장: 오류 제어/흐름 제어/ 회선 제어
    - 오류제어: 검출은 여기서 하고 수정은 전송 계층에서
    - 흐름제어: 전송 데이ㅓ의 양을 제한하는 기술
    - 회선제어: 신호 간 충돌이 발생하지 않도록 제어하는 기술
- 네트워크
  - 단위: 패킷, 장치는 라우터
  - 라우팅 프로토콜을 사용하여 최적의 경로 선택, IP주소를 지정
- 전송: TCP, UDP
  - 단위: 세그먼트
  - 신뢰성 있는 데이터를 주고 받을 수 있게 함
  - 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 함: **어떻게?**
- 세션
  - 단위: 데이터, 장치는 L5 스위치
  - 양측 응용 프로세스가 통신을 관리하기 위한 방법을 제공
  - TCP/IP 세션을 만들고 없앰
- 표현
  - 단위: 데이터
  - 데이터 부호화, 변환: 파일 인코딩이나 명령어 포장/압축/암호화 등을 진행
  - 암호화 등을 통해 코드 간의 번역을 함
- 어플리케이션
  - 단위는 메세지, 데이터
  - 직접적으로 응용 프로세스와 관계하여 여러 가지 프로토콜 개체에 대해 UI 제공
  - HTTP, FTP, POP3 등의 프로토콜 사용



#### TCP/IP

- TCP: 전화를 거는 것처럼 연결, 안정적으로, **순서대로, 에러 없이**
  - 3-way handshake: 연결 설정, 수락, 확인
    1. 통신하고 싶다는 메시지 보내기(SYN)
    2. 상대가 준비됐다고 보냄(SYN+ACK)
       1. 연결 종료 시엔 여기에 FIN를 상대로부터 추가로 받음
    3. ACK로 응답
  - 데이터를 분할해 고유번호를 부여하고 그를 이용해 데이터가 잘 전달됐는지 확인
  - 확인응답(ACK)를 계속 보내 신뢰성 확보
- UDP: TCP에서 신뢰성 기능을 뺀 것(스트리밍 하려고 만든 것임)
  - 실시간성을 보장해 줌
  - DNS 는 request의 양이 적고 연결을 유지할 필요가 없기 때문에 UDP를 사용함
- IP: 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 **정보 위주**의 규약
  - **호스트**의 주소 지정, 패킷 분할 및 조립 기능 담당
    - 호스트란 네트워크에 연결된 "컴퓨터"를 말함
  - 각 장치를 나타내는 주소: **호스트**나 라우터 장비의 인터페이스에 할당
    - MAC주소는 물리 주소: 한 IP주소 내에 다양한 *기기* 들이 있을 때 각각을 식별함
    - IP는 Host to Host이기 때문에 장비 내 **프로세스간 통신을 위해서 포트 번호 필요**
  - 비신뢰성/비연결형
  - 에러제어, 흐름제어 없음: 에러 검출은 하지만 보낸 내용을 보장하지 않음
  - MTU(Maximun Transfer Unit)때문에 IP패킷을 잘라서(단편화) 보냄
  - IPv6
    - IPv4가 가진 주소 고갈, 보안성, 이동성 지원 등을 해결하기 위해 등장
    - 보안성: 패킷 출처 인증, 데이터 무결서 및 비밀 보장 기능
    - 이동성: 네트워크의 물리적 위치에 제한받지 않음
- 흐름제어/혼잡제어
  - 흐름제어: **송신측과 수신측**의 데이터 처리속도 차이 해결
    - receiver가 sender에게 현재 자신의 상태를 feedback하여 패킷을 지나치게 많이 받지 않도록 함
    - Stop & Wait: 매 패킷마다 확인 응답을 받고 그 다음 패킷을 전송
    - Sliding Window: **수신측에서** 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트 전송, ACK를 받으면 버퍼의 범위가 한꺼번에 이동
  - 혼잡제어: **송신측의 데이터 전달과 네트워크**의 데이터 처리 속도 차이를 해결
    - 한마디로 많이보내면 혼잡해지니까 속도를 조절하는 것
    - Slow Start: 패킷을 하나씩 보내고 임계치에 도달할 때까지 윈도우 사이즈 2배씩 증가시키나 혼잡이 감지되면 사이즈를 다시 1로 떨구고 혼잡의 절반까지 증가시킴
    - Congestion Avoidance: 임계치를 넘으면 선형적으로 증가
    - Fast Retransmit: 중복된 패킷을 3개 받으면 혼잡이 일어나 손실됐다고 간주, **즉시 재전송**
    - Fast Recovery: 혼잡 이후 윈도우 사이즈를 1이 아닌 절반으로 내리고 선형증가시킴



### 2.6. SE





## 3. 기타

> 2번에서 다루지 않은 항목 정리



### 3.1. 소프트웨어 설계

디자인 패턴



### 3.2. 소프트웨어 개발



### 3.3. 프로그래밍 언어



### 3.4. 웹

#### 웹 기본

- HTTP
  - HyperText Transfer Protocol: 웹브라우저와 웹서버가 통신할 때 사용하는 규칙
  - Request와 Response로 나뉨
  - Request
    - 요청라인(method, URL, version) + 헤더 + 공백 + 바디
  - Response
    - 상태라인 + 헤더 + 공백 + 바디
- REST API
  - REST란? 
    - REpresentational State Transfer
    - 웹에 존재하는 모든 자원에 URI를 부여하고, HTTP method를 통해 해당 자원에 대한 CRUD operation을 적용
    - 자원, 행위, 표현(JSON, XML, txt)
  - API란?
    - Application Programming Interface
    - 응용프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
  - 이해하기 쉽고, 모든 플랫폼 사용 가능하며(서버와 클라이언트가 같은 방식을 사용해서 요청해야) 별도의 인프라 구축 필요 없으나 메서드가 제한적이라는 단점 있음
- 브라우저
  - 구성: UI - 브라우저 엔진 - 렌더링 엔진, 통신, JS해석기, 임시파일저장소
    - ![ㅇ](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)
  - 렌더링 동작 과정
    - html가져옴 - **DOM트리 작성** - CSSOM트리 작성 - 2개 결합해 렌더트리 생성
    - 객체들에게 위치,크기 지정(레이아웃) - CSS속성 적용 - 화면 업데이트
    - 도중에 JS를 발견하면 JS엔진 실행했다가 다시 DOM 생성함
  - SSR: Server Side Rendering
    - 서버에서 view페이지를 렌더링해서 가져옴
    - 서버 부담, 매번 새로 렌더링하니 느림
  - CSR: Client Side Rendering
    - 서버에서 html, js등을 다운받은 후 브라우저에서 렌더링
  - SEO: Search Engine Optimization
    - JS가 검색엔진에 최적화되어 있지 않음: **왜?**
      - *자료를 수집하고 순위를 매기기 때문인가?*
    - 첫번째 페이지는 SSR로, 이후에는 CSR을 이용하는 방안이 가능
  - SPA: Single Page Application
    - 기본적으로 페이지 로딩이 없음 **진짜?**
    - 모바일에 특화?
    - React는 SPA를 만들기에 최적화되어 있음
      - 검색이 잘 안될 수 있으므로 Next.js 등의 라이브러리가 등장
  - babel: transpiler
    - ES5을 사용하는 대부분의 브라우저들을 위해 ES6로 바꿔주는 기능
  - Webpack
    - 현대 JS 어플리케이션을 위한 정적인 **모듈 번들러**
    - 모듈 번들러: 여러 개로 나누어져 있는 파일들을 하나의 파일로 통합해줌
    - Entry(build 시작), Output(이 경로를 통해 빌드 파일 생성), Loaders(css, img 파일 등을 이해할 수 있게 함), plugins(번들된 결과물 처리), Mode()

- 쿠키와 캐시의 [차이](https://zorba91.tistory.com/163)
  - 쿠키는 키-값의 데이터 파일, 제한시간 존재, 웹서버에서 PC로 보내주는 파일 저장, 웹사이트 접속시 발생, 유출되도 큰 일 없을 정보들
  - 캐시는 웹페이지요소(Response), 그림파일 등, 웹페이지를 빠르게 렌더링하는 것을 도와줌, 수동 삭제

- 세션
  - 사이트와 브라우저 사이의 상태를 유지시킴. 연결 그 자체 & 통신을 마칠 때까지의 기간
  - 클라이언트는 세션 아이디(클라이언트 식별자)를 쿠키를 이용해 저장
  - 세션 자체는 서버에 저장

#### 토큰

> 본인 확인 수단: 

- 요청 토큰: 소비자가 사용자에게 접근권한을 인증받기 위해 필요한 정보
- 접근 토큰: 인증 후에 사용자가 소비자를 통해 보호 자원에 접근하기 위한 키 값
- CSRF 토큰
  - 랜덤한 수를 사용자 세션에 저장하고, 요청 페이지에 CSRF 토큰을 담아 전송함
  - CSRF는 서버를 공격, XSS는 클라이언트를 공격

#### UI, UX

- UI
  - 사용자가 앱을 사용할 때 마주하는 디자인, 레이아웃, 기술적 부분
  - 사용할 때 불편함이 없어야 함
- UX
  - 사용자 경험을 분석하여 편하고 효율적으로 진행되도록 하는 것
  - UI가 포장이라면 UX는 내용물



#### 네이티브 앱 vs 웹 앱 vs 하이브리드 앱

- 네이티브 앱
  - 모바일 OS(안드로이드, iOS)에 최적화된 어어로 개발된 앱
  - OS 자체의 기능을 사용하여 성능이 높고 사용성이 좋음
  - **네이티브 API**를 호출하여 플랫폼과 밀착됨
- 하이브리드 앱
  - 앱의 특정 부분의 브라우저를 올려서 HTML을 불러옴
  - 수정하기 좋지만 네트워크에 종속되어 느릴 수 있음
- 모바일 웹
  - 데스크탑 웹 애플리케이션의 사이즈만 줄인 것
- 웹 앱
  - 모바일 웹과 네이티브 앱을 결합한 것
  - SPA를 활용하여 속도가 빠름
  - 따로 설치할 필요 없으나 브라우저 API만 사용가능함



### 3.5. Linux



### 3.6. Git

#### Git의 원리[링크](https://www.slideshare.net/ky200223/git-89251791)

- 버전 관리 기능
  - 커밋 당시 디렉토리의 파일 정보를 저장하고, Hash하여 변경사항을 빠르게 체크
- SVN과의 차이
  - 브랜칭
  - Git은 로컬에서만 돌리는 것도 가능
  - 

[Git Flow, GitHub Flow, GitLab Flow](https://ujuc.github.io/2015/12/16/git-flow-github-flow-gitlab-flow/)

### 3.7. IT업계 전반





## 4. 코딩테스트 기출문제

> 나올 가능성은 적지만 코테 복기시킬 수 있으니 풀었던 방식, 개선방안 정리하자



### 1차

#### 1번

#### 2번

#### 3번

#### 4번

#### 5번

#### 6번

#### 7번



### 2차

